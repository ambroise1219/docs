# Testing

Ce guide explique comment tester l'API ONO Backend, y compris les tests unitaires, d'int√©gration et de performance.

## üß™ Types de tests

L'API ONO Backend utilise plusieurs types de tests pour garantir la qualit√© du code :

1. **Tests unitaires** - Testent des unit√©s individuelles de code
2. **Tests d'int√©gration** - Testent l'interaction entre les composants
3. **Tests d'API** - Testent les endpoints HTTP
4. **Tests de performance** - √âvaluent les performances sous charge

## üõ†Ô∏è Configuration des tests

### Variables d'environnement de test

Cr√©ez un fichier `.env.test` pour les tests :

```env
ENVIRONMENT=testing
TEST_DATABASE_URL=postgresql://user:password@localhost:5432/ono_test
JWT_SECRET=test-secret-key
```

### Base de donn√©es de test

Cr√©ez une base de donn√©es d√©di√©e aux tests :

```sql
CREATE DATABASE ono_test;
```

## üß™ Tests unitaires

### Ex√©cuter tous les tests unitaires

```bash
cargo test
```

### Ex√©cuter les tests d'un module sp√©cifique

```bash
cargo test food
cargo test delivery
cargo test auth
```

### Exemple de test unitaire

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_calculate_delivery_fee() {
        let distance = 5.0; // 5 km
        let expected_fee = 1500; // 1500 XOF
        let fee = calculate_delivery_fee(distance);
        assert_eq!(fee, expected_fee);
    }
}
```

## üîå Tests d'int√©gration

### Scripts de test shell

Le projet inclut plusieurs scripts de test d'int√©gration :

```bash
# Tester toutes les fonctionnalit√©s food
./tests/test_all_food_endpoints.sh

# Tester le CRUD des cat√©gories
./tests/food_categories_test.sh

# Tester le CRUD des suppl√©ments
./tests/food_supplements_test.sh

# Tester le flux complet
./tests/food_complete_flow_test.sh

# Test rapide
./tests/food_quick_test.sh
```

### Exemple de script de test

```bash
#!/bin/bash

# test_restaurant_crud.sh

echo "=== Test CRUD Restaurant ==="

# Cr√©er un restaurant
echo "1. Cr√©ation d'un restaurant..."
response=$(curl -s -X POST http://localhost:3000/api/food/restaurants \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Test Restaurant",
    "address": "123 Test Street",
    "city": "Test City"
  }')

restaurant_id=$(echo $response | jq -r '.data.id')
echo "Restaurant cr√©√© avec ID: $restaurant_id"

# R√©cup√©rer le restaurant
echo "2. R√©cup√©ration du restaurant..."
curl -s -X GET http://localhost:3000/api/food/restaurants/$restaurant_id \
  -H "Authorization: Bearer $TOKEN"

# Mettre √† jour le restaurant
echo "3. Mise √† jour du restaurant..."
curl -s -X PUT http://localhost:3000/api/food/restaurants/$restaurant_id \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Updated Test Restaurant"
  }'

# Supprimer le restaurant
echo "4. Suppression du restaurant..."
curl -s -X DELETE http://localhost:3000/api/food/restaurants/$restaurant_id \
  -H "Authorization: Bearer $TOKEN"

echo "=== Test termin√© ==="
```

## üåê Tests d'API avec Postman

### Collections Postman

Le projet inclut des collections Postman pour tester les APIs :

- `ONO_FOOD.postman_collection.json` - Tests pour le module Food
- `ONO_USERS.postman_collection.json` - Tests pour le module Users

### Ex√©cution avec Newman

Installez Newman pour ex√©cuter les collections Postman en ligne de commande :

```bash
npm install -g newman
```

Ex√©cutez une collection :

```bash
newman run ONO_FOOD.postman_collection.json -e environment.json
```

## üöÄ Tests de performance

### Configuration k6

k6 est un outil de test de performance pour les APIs. Cr√©ez un fichier de test [k6](file:///Users/ambroisek/Documents/ono/ono_backend/target/debug/ono-backend) :

```javascript
// food_performance_test.js

import http from 'k6/http';
import { check, sleep } from 'k6';

export let options = {
  stages: [
    { duration: '30s', target: 100 }, // Monter √† 100 utilisateurs en 30s
    { duration: '1m', target: 100 },  // Rester √† 100 utilisateurs pendant 1m
    { duration: '30s', target: 0 },   // Redescendre √† 0 utilisateurs en 30s
  ],
};

export default function () {
  // Test de l'endpoint de liste des restaurants
  let res = http.get('http://localhost:3000/api/food/restaurants');
  check(res, {
    'status is 200': (r) => r.status === 200,
  });
  
  sleep(1);
}
```

Ex√©cutez le test :

```bash
k6 run food_performance_test.js
```

### R√©sultats de test k6

k6 fournit des m√©triques d√©taill√©es :

```
data_received..............: 1.2 MB 20 kB/s
data_sent..................: 60 kB  1.0 kB/s
http_req_blocked...........: avg=1.2ms  min=0s     med=0s     max=15ms   p(90)=3ms    p(95)=5ms
http_req_connecting........: avg=0.8ms  min=0s     med=0s     max=10ms   p(90)=2ms    p(95)=3ms
http_req_duration..........: avg=45ms   min=30ms   med=42ms   max=120ms  p(90)=55ms   p(95)=65ms
http_req_receiving.........: avg=0.5ms  min=0s     med=0s     max=5ms    p(90)=1ms    p(95)=2ms
http_req_sending...........: avg=0.3ms  min=0s     med=0s     max=3ms    p(90)=0.5ms  p(95)=1ms
http_req_waiting...........: avg=44ms   min=29ms   med=41ms   max=119ms  p(90)=54ms   p(95)=64ms
http_reqs..................: 1500   25.0/s
iteration_duration.........: avg=1.04s  min=1.03s  med=1.04s  max=1.15s  p(90)=1.05s  p(95)=1.06s
iterations.................: 1500   25.0/s
vus........................: 100    min=100  max=100
vus_max....................: 100    min=100  max=100
```

## üß∞ Outils de test

### Cargo test

L'outil de test int√©gr√© de Rust :

```bash
# Ex√©cuter tous les tests
cargo test

# Ex√©cuter les tests avec plus de verbosit√©
cargo test -- --nocapture

# Ex√©cuter les tests en parall√®le
cargo test -- --test-threads=4

# Ex√©cuter un test sp√©cifique
cargo test test_function_name
```

### SQLx pour les tests de base de donn√©es

```rust
#[cfg(test)]
mod db_tests {
    use sqlx::PgPool;

    #[sqlx::test]
    async fn test_user_creation(pool: PgPool) -> sqlx::Result<()> {
        let user = create_user(&pool, "test@example.com").await?;
        assert_eq!(user.email, "test@example.com");
        Ok(())
    }
}
```

### Mocking avec mockall

Pour mocker les d√©pendances dans les tests :

```rust
#[cfg(test)]
use mockall::*;

#[cfg_attr(test, automock)]
trait PaymentService {
    fn process_payment(&self, amount: u32) -> Result<(), PaymentError>;
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_process_order() {
        let mut mock_payment = MockPaymentService::new();
        mock_payment
            .expect_process_payment()
            .with(eq(1000))
            .times(1)
            .returning(|_| Ok(()));
            
        let result = process_order(&mock_payment, 1000);
        assert!(result.is_ok());
    }
}
```

## üìä Couverture de test

### Installation de cargo-tarpaulin

```bash
cargo install cargo-tarpaulin
```

### G√©n√©rer un rapport de couverture

```bash
cargo tarpaulin --out Html
```

Cela g√©n√©rera un rapport HTML dans `tarpaulin-report.html`.

## üîç Tests de mutation avec cargo-mutants

### Installation

```bash
cargo install cargo-mutants
```

### Ex√©cuter les tests de mutation

```bash
cargo mutants
```

## üõ°Ô∏è Tests de s√©curit√©

### Audit des d√©pendances

```bash
cargo audit
```

### Tests d'injection SQL

Utilisez sqlmap ou des tests manuels pour v√©rifier les vuln√©rabilit√©s d'injection SQL :

```bash
# Exemple de test d'injection SQL
curl "http://localhost:3000/api/food/restaurants?city=' OR '1'='1"
```

## üìà Tests de charge avec wrk

### Installation

```bash
# Sur macOS
brew install wrk

# Sur Ubuntu
sudo apt-get install wrk
```

### Ex√©cuter un test de charge

```bash
wrk -t12 -c400 -d30s http://localhost:3000/api/food/restaurants
```

Options :
- `-t12` : 12 threads
- `-c400` : 400 connexions HTTP
- `-d30s` : Dur√©e du test (30 secondes)

## üßπ Bonnes pratiques de test

### 1. Structure des tests

```rust
#[cfg(test)]
mod tests {
    use super::*;

    // Given-When-Then pattern
    #[test]
    fn test_create_restaurant_success() {
        // Given
        let restaurant_data = RestaurantData {
            name: "Test Restaurant".to_string(),
            // ... autres champs
        };
        
        // When
        let result = create_restaurant(restaurant_data);
        
        // Then
        assert!(result.is_ok());
        let restaurant = result.unwrap();
        assert_eq!(restaurant.name, "Test Restaurant");
    }
}
```

### 2. Tests param√©tr√©s

```rust
#[cfg(test)]
mod parameterized_tests {
    use super::*;
    use test_case::test_case;

    #[test_case(1.0, 2.0, 3.0; "positive numbers")]
    #[test_case(-1.0, -2.0, -3.0; "negative numbers")]
    #[test_case(0.0, 0.0, 0.0; "zeros")]
    fn test_add(a: f64, b: f64, expected: f64) {
        assert_eq!(add(a, b), expected);
    }
}
```

### 3. Tests d'erreurs

```rust
#[test]
fn test_create_restaurant_invalid_data() {
    // Given
    let invalid_data = RestaurantData {
        name: "".to_string(), // Nom vide
        // ... autres champs invalides
    };
    
    // When
    let result = create_restaurant(invalid_data);
    
    // Then
    assert!(result.is_err());
    match result.unwrap_err() {
        RestaurantError::ValidationError(_) => (),
        _ => panic!("Expected ValidationError"),
    }
}
```

Avec ces outils et pratiques, vous pouvez garantir la qualit√©, la fiabilit√© et les performances de l'API ONO Backend.